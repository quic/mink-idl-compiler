#pragma once
// AUTOGENERATED FILE: DO NOT EDIT

#include <stdint.h>
#include "object.h"
#include "ITest.h"

#define ITest1_DEFINE_INVOKE(func, prefix, type) \
  int32_t func(ObjectCxt h, ObjectOp op, ObjectArg *a, ObjectCounts k) \
  { \
    type me = (type) h; \
    switch (ObjectOp_methodID(op)) { \
      case Object_OP_release: { \
        if (k != ObjectCounts_pack(0, 0, 0, 0)) { \
          break; \
        } \
        return prefix##release(me); \
      } \
      case Object_OP_retain: { \
        if (k != ObjectCounts_pack(0, 0, 0, 0)) { \
          break; \
        } \
        return prefix##retain(me); \
      } \
      case ITest1_OP_test_f1: { \
        if (k != ObjectCounts_pack(1, 1, 0, 0) || \
          a[0].b.size != 4 || \
          a[1].b.size != 4) { \
          break; \
        } \
        const uint32_t *a_ptr = (const uint32_t*)a[0].b.ptr; \
        uint32_t *b_ptr = (uint32_t*)a[1].b.ptr; \
        return prefix##test_f1(me, *a_ptr, b_ptr); \
      } \
      case ITest1_OP_in_struct: { \
        if (k != ObjectCounts_pack(1, 0, 0, 0) || \
          a[0].b.size != 24) { \
          break; \
        } \
        const Collection *input_ptr = (const Collection*)a[0].b.ptr; \
        return prefix##in_struct(me, input_ptr); \
      } \
      case ITest1_OP_out_struct: { \
        if (k != ObjectCounts_pack(0, 1, 0, 0) || \
          a[0].b.size != 24) { \
          break; \
        } \
        Collection *output_ptr = (Collection*)a[0].b.ptr; \
        return prefix##out_struct(me, output_ptr); \
      } \
      case ITest1_OP_single_out: { \
        if (k != ObjectCounts_pack(0, 1, 0, 0) || \
          a[0].b.size != 4) { \
          break; \
        } \
        uint32_t *output_ptr = (uint32_t*)a[0].b.ptr; \
        return prefix##single_out(me, output_ptr); \
      } \
      case ITest1_OP_single_in: { \
        if (k != ObjectCounts_pack(1, 0, 0, 0) || \
          a[0].b.size != 4) { \
          break; \
        } \
        const uint32_t *input_ptr = (const uint32_t*)a[0].b.ptr; \
        return prefix##single_in(me, *input_ptr); \
      } \
      case ITest1_OP_single_primitive_in: { \
        if (k != ObjectCounts_pack(2, 1, 0, 0) || \
          a[1].b.size != 4) { \
          break; \
        } \
        const void *unused_ptr = (const void*)a[0].b.ptr; \
        size_t unused_len = a[0].b.size / 1; \
        void *unused2_ptr = (void*)a[2].b.ptr; \
        size_t unused2_len = a[2].b.size / 1; \
        const uint32_t *input_ptr = (const uint32_t*)a[1].b.ptr; \
        int32_t r = prefix##single_primitive_in(me, unused_ptr, unused_len, unused2_ptr, unused2_len, &unused2_len, *input_ptr); \
        a[2].b.size = unused2_len * 1; \
        return r; \
      } \
      case ITest1_OP_single_primitive_out: { \
        if (k != ObjectCounts_pack(1, 2, 0, 0) || \
          a[2].b.size != 4) { \
          break; \
        } \
        const void *unused_ptr = (const void*)a[0].b.ptr; \
        size_t unused_len = a[0].b.size / 1; \
        void *unused2_ptr = (void*)a[1].b.ptr; \
        size_t unused2_len = a[1].b.size / 1; \
        uint32_t *output_ptr = (uint32_t*)a[2].b.ptr; \
        int32_t r = prefix##single_primitive_out(me, unused_ptr, unused_len, unused2_ptr, unused2_len, &unused2_len, output_ptr); \
        a[1].b.size = unused2_len * 1; \
        return r; \
      } \
      case ITest1_OP_multiple_primitive: { \
        if (k != ObjectCounts_pack(2, 3, 1, 1) || \
          a[0].b.size != 6 || \
          a[2].b.size != 10) { \
          break; \
        } \
        const struct { \
          uint32_t m_input2; \
          uint16_t m_input; \
        } *i = a[0].b.ptr; \
        struct { \
          uint64_t m_output2; \
          uint16_t m_output; \
        } *o = a[2].b.ptr; \
        const void *unused_ptr = (const void*)a[1].b.ptr; \
        size_t unused_len = a[1].b.size / 1; \
        void *unused2_ptr = (void*)a[3].b.ptr; \
        size_t unused2_len = a[3].b.size / 1; \
        void *unused5_ptr = (void*)a[4].b.ptr; \
        size_t unused5_len = a[4].b.size / 1; \
        int32_t r = prefix##multiple_primitive(me, unused_ptr, unused_len, unused2_ptr, unused2_len, &unused2_len, i->m_input, &o->m_output, a[5].o, &a[6].o, i->m_input2, &o->m_output2, unused5_ptr, unused5_len, &unused5_len); \
        a[3].b.size = unused2_len * 1; \
        a[4].b.size = unused5_len * 1; \
        return r; \
      } \
      case ITest1_OP_primitive_plus_struct_in: { \
        if (k != ObjectCounts_pack(1, 0, 0, 0) || \
          a[0].b.size != 8) { \
          break; \
        } \
        const struct { \
          SingleEncapsulated m_encapsulated; \
          uint32_t m_magic; \
        } *i = a[0].b.ptr; \
        return prefix##primitive_plus_struct_in(me, &i->m_encapsulated, i->m_magic); \
      } \
      case ITest1_OP_primitive_plus_struct_out: { \
        if (k != ObjectCounts_pack(0, 1, 0, 0) || \
          a[0].b.size != 8) { \
          break; \
        } \
        struct { \
          SingleEncapsulated m_encapsulated; \
          uint32_t m_magic; \
        } *o = a[0].b.ptr; \
        return prefix##primitive_plus_struct_out(me, &o->m_encapsulated, &o->m_magic); \
      } \
      case ITest1_OP_bundled_with_unbundled: { \
        if (k != ObjectCounts_pack(2, 0, 0, 0) || \
          a[0].b.size != 8 || \
          a[1].b.size != 24) { \
          break; \
        } \
        const struct { \
          SingleEncapsulated m_bundled; \
          uint32_t m_magic; \
        } *i = a[0].b.ptr; \
        const Collection *unbundled_ptr = (const Collection*)a[1].b.ptr; \
        return prefix##bundled_with_unbundled(me, &i->m_bundled, i->m_magic, unbundled_ptr); \
      } \
    } \
    return Object_ERROR_INVALID; \
  }

#define ITest2_DEFINE_INVOKE(func, prefix, type) \
  int32_t func(ObjectCxt h, ObjectOp op, ObjectArg *a, ObjectCounts k) \
  { \
    type me = (type) h; \
    switch (ObjectOp_methodID(op)) { \
      case Object_OP_release: { \
        if (k != ObjectCounts_pack(0, 0, 0, 0)) { \
          break; \
        } \
        return prefix##release(me); \
      } \
      case Object_OP_retain: { \
        if (k != ObjectCounts_pack(0, 0, 0, 0)) { \
          break; \
        } \
        return prefix##retain(me); \
      } \
      case ITest2_OP_test_f2: { \
        if (k != ObjectCounts_pack(1, 0, 0, 0) || \
          a[0].b.size != 4) { \
          break; \
        } \
        const F1 *f_ptr = (const F1*)a[0].b.ptr; \
        return prefix##test_f2(me, f_ptr); \
      } \
      case ITest2_OP_test_obj_in: { \
        if (k != ObjectCounts_pack(0, 1, 1, 0) || \
          a[0].b.size != 4) { \
          break; \
        } \
        uint32_t *a_ptr = (uint32_t*)a[0].b.ptr; \
        return prefix##test_obj_in(me, a[1].o, a_ptr); \
      } \
      case ITest2_OP_test_obj_out: { \
        if (k != ObjectCounts_pack(0, 0, 0, 1)) { \
          break; \
        } \
        return prefix##test_obj_out(me, &a[0].o); \
      } \
      case ITest2_OP_test_bundle: { \
        if (k != ObjectCounts_pack(3, 2, 0, 0) || \
          a[0].b.size != 9 || \
          a[3].b.size != 10) { \
          break; \
        } \
        const struct { \
          uint32_t m_a; \
          uint32_t m_c; \
          uint8_t m_b; \
        } *i = a[0].b.ptr; \
        struct { \
          uint32_t m_d; \
          uint32_t m_f; \
          uint16_t m_e; \
        } *o = a[3].b.ptr; \
        const void *xxx_ptr = (const void*)a[1].b.ptr; \
        size_t xxx_len = a[1].b.size / 1; \
        void *yyy_ptr = (void*)a[4].b.ptr; \
        size_t yyy_len = a[4].b.size / 1; \
        const void *xxx1_ptr = (const void*)a[2].b.ptr; \
        size_t xxx1_len = a[2].b.size / 1; \
        int32_t r = prefix##test_bundle(me, xxx_ptr, xxx_len, yyy_ptr, yyy_len, &yyy_len, i->m_a, xxx1_ptr, xxx1_len, i->m_b, i->m_c, &o->m_d, &o->m_e, &o->m_f); \
        a[4].b.size = yyy_len * 1; \
        return r; \
      } \
      case ITest2_OP_test_array: { \
        if (k != ObjectCounts_pack(3, 3, 0, 0) || \
          a[0].b.size != 6 || \
          a[3].b.size != 8) { \
          break; \
        } \
        const struct { \
          F1 m_f_y; \
          int16_t m_d; \
        } *i = a[0].b.ptr; \
        struct { \
          F1 m_f_x; \
          int32_t m_c; \
        } *o = a[3].b.ptr; \
        const F1 *f_in_ptr = (const F1*)a[1].b.ptr; \
        size_t f_in_len = a[1].b.size / sizeof(F1); \
        F1 *f_out_ptr = (F1*)a[4].b.ptr; \
        size_t f_out_len = a[4].b.size / sizeof(F1); \
        const uint32_t *a_ptr = (const uint32_t*)a[2].b.ptr; \
        size_t a_len = a[2].b.size / sizeof(uint32_t); \
        uint32_t *b_ptr = (uint32_t*)a[5].b.ptr; \
        size_t b_len = a[5].b.size / sizeof(uint32_t); \
        int32_t r = prefix##test_array(me, f_in_ptr, f_in_len, f_out_ptr, f_out_len, &f_out_len, &o->m_f_x, &i->m_f_y, a_ptr, a_len, b_ptr, b_len, &b_len, &o->m_c, i->m_d); \
        a[4].b.size = f_out_len * sizeof(F1); \
        a[5].b.size = b_len * sizeof(uint32_t); \
        return r; \
      } \
    } \
    return Object_ERROR_INVALID; \
  }


