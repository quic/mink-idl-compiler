// Copyright (c) 2024, Qualcomm Innovation Center, Inc. All rights reserved.
// SPDX-License-Identifier: BSD-3-Clause

//! Provides Mink objects
//!
//! Most of the functionality in this file is intended only for internal use by
//! code generated from minkidl. Applications should use objects primarily via
//! the generated stub wrappers and invoke macros.

pub mod error;
#[cfg(feature = "std")]
pub mod wrapper;
pub use error::Error;

/// `Object_OK`
pub const OK: i32 = 0;

pub type Counts = u32;
pub type Op = u32;
pub type Ctx = *mut core::ffi::c_void;
pub type Invoke = unsafe extern "C" fn(h: Ctx, op: Op, args: *mut Arg, counts: Counts) -> i32;

#[repr(C)]
#[derive(Debug, PartialEq, Hash)]
/// Mink [`Object`] is an opaque type that allows you to IPC between services.
pub struct Object {
    /// Function pointer containing the [`Object`]'s invoke function.
    invoke: Invoke,
    /// Context of the current [`Object`].
    context: Ctx,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
/// Input buffer with ptr + size fields.
///
/// # Do not use in application code, this is a minkidl intrinsic.
pub struct BufOut {
    pub ptr: *mut core::ffi::c_void,
    pub size: usize,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
/// Output buffer with ptr + size fields.
///
/// # Do not use in application code, this is a minkidl intrinsic.
pub struct BufIn {
    pub ptr: *const core::ffi::c_void,
    pub size: usize,
}

/// Argument to [`Invoke`].
///
/// # Do not use in application code, this is a minkidl intrinsic.
#[repr(C)]
#[allow(improper_ctypes, improper_ctypes_definitions)]
pub union Arg {
    pub b: BufOut,
    pub bi: BufIn,
    pub o: core::mem::ManuallyDrop<Option<Object>>,
}

pub const OP_RELEASE: Op = 0xffffu32;
pub const OP_RETAIN: Op = 0xfffeu32;

#[inline]
/// Pack argument counts into single [`Counts`] field for [`Invoke`].
///
/// # Do not use in application code, this is a minkidl intrinsic.
pub const fn pack_counts(
    n_buffers_in: Counts,
    n_buffers_out: Counts,
    n_objects_in: Counts,
    n_objects_out: Counts,
) -> Counts {
    n_buffers_in | (n_buffers_out << 4) | (n_objects_in << 8) | (n_objects_out << 12)
}

impl Drop for Object {
    /// This calls the object's [`OP_RELEASE`] function.
    ///
    /// This does **NOT** ensure that the Object resources are cleaned up. Internal implementations
    /// will drop [Objects](Object) based on the knowledge that there are no references remaining.
    /// It's idiomatic to think of this as a reference counted container like [`Rc`](std::rc::Rc)
    ///
    /// # Panics
    /// On **debug-mode**, all drops that don't succeed will panic. [`OP_RELEASE`] are infalliable,
    /// in which case we live with a memory-leak if the drop fails to avoid panicking in
    /// production.
    fn drop(&mut self) {
        if unsafe { self.invoke(OP_RELEASE, core::ptr::null_mut(), 0u32) } != 0 {
            unreachable!(
                "Object drop didn't succeed. This is the result of undefined
            behaviour, if you believe this is a bug please submit
            reproduction/fix steps as an issue"
            );
        }
    }
}

impl Clone for Object {
    #[inline]
    /// Calls the object's [`OP_RETAIN`] function and creates a [__Shallow
    /// Copy__](struct.Object.html#what-does-it-do) of the object.
    ///
    /// This does **NOT** increase Object table count.
    ///
    /// # What does it do?
    /// Internally, this returns the same object but ensures that the owned object is safe to use
    /// beyond the lifetime of the original reference. This is to be treated similar to how
    /// [`Rc`](std::rc::Rc) clones are treated i.e the cloned result share resources.
    ///
    /// # Panics
    /// This panics if the retain call on the object returns a failure, which is
    /// only expected in case the object's reference counter overflows and
    /// should never happen in practice.
    fn clone(&self) -> Self {
        if unsafe { self.invoke(OP_RETAIN, core::ptr::null_mut(), 0u32) } != 0 {
            unreachable!();
        }
        unsafe { core::ptr::read(self) }
    }
}

/// Marker trait for typed [`Object`] wrappers. This allows for a lot of unsafe
/// casts. This is an Mink intrinsic and not expected to be used outside
/// autogenerated code.
///
/// # Safety
///
/// This trait is **NOT** to be implemented for types that don't provide the
/// same ABI as [`Object`]. Any other implementation will be unsound!!!
pub unsafe trait TypedObject: Sized {
    #[inline(always)]
    /// Returns the inner [`Object`] out of [`Self`]
    fn into_raw(self) -> Object {
        debug_assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Object>());
        let me = core::mem::ManuallyDrop::new(self);
        unsafe { core::ptr::read(core::ptr::addr_of!(me).cast()) }
    }

    #[inline(always)]
    /// Constructs a typed [`Object`] out of a raw value.
    ///
    /// # Safety
    ///
    /// This function exhibits safe behavior as long as the `raw` [`Object`] is
    /// the same type as [`Self`].
    unsafe fn from_raw(raw: Object) -> Self {
        debug_assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Object>());
        let raw = core::mem::ManuallyDrop::new(raw);
        unsafe { core::ptr::read(core::ptr::addr_of!(raw).cast()) }
    }

    #[inline(always)]
    /// Constructs a typed [`Object`] reference out of a raw reference.
    ///
    /// # Safety
    ///
    /// This function exhibits safe behavior as long as `raw` references a valid
    /// Object of type [`Self`].
    unsafe fn from_raw_ref(raw: &Object) -> &Self {
        debug_assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Object>());
        core::mem::transmute(raw)
    }
}

/// Trait for defining ways to obtain Objects.
pub trait Transport {
    /// Allows for communication with the type behind `uid`. See
    /// [`Transport::open_with_uid_singleton`] if multiple references to the
    /// same object is needed.
    ///
    /// # Safety
    ///
    /// It's caller's responsibility to ensure the uid is correctly bound to the
    /// interface being used.
    fn open_with_uid<T: TypedObject>(uid: u32) -> Result<T, Error>;

    /// Allows for communication with the type behind `uid`. Using this function
    /// **may** use a spot in your object table until the end of your
    /// application. If this is not the behavior you want, see
    /// [`Transport::open_with_uid`].
    ///
    /// # Safety
    ///
    /// It's caller's responsibility to ensure the uid is correctly bound to the
    /// interface being used.
    fn open_with_uid_singleton<T: TypedObject>(uid: u32) -> Result<T, Error>;
}

#[cfg(feature = "std")]
pub trait TransportExt: Transport {
    /// Allows for communication with the [`Object`] created using input `path`
    fn open_at<T: TypedObject>(path: &std::path::Path) -> Result<T, Error>;
}

impl Object {
    #[inline(always)]
    /// Call invoke on object.
    ///
    /// # Do not use in application code, this is a minkidl intrinsic.
    ///
    /// # Safety
    /// This is safe (no UB) as long as object is valid, i.e., it contains a
    /// valid invoke pointer and context is valid for given invoke.
    pub unsafe fn invoke(&self, op: Op, args: *mut Arg, counts: Counts) -> i32 {
        (self.invoke)(self.context, op, args, counts)
    }

    /// Create new object.
    ///
    /// # Do not use in application code, this is a minkidl intrinsic.
    ///
    /// To create a new object, applications should either
    /// - Request a new remote object via the correspondong system interface,
    /// - Create a new local object using the create function defined by an
    ///   invoke macro.
    /// - Clone an existing object.
    ///
    /// # Safety
    /// This is safe (no UB) as long as object is valid, i.e., it contains a
    /// valid invoke pointer and context is valid for given invoke.
    pub const unsafe fn create(invoke: Invoke, context: Ctx) -> Self {
        Self { invoke, context }
    }

    #[inline]
    #[cfg(feature = "std")]
    /// Obtain the pointer to context if this object's invoke matches given
    /// value.
    ///
    /// # Do not use in application code, this is a minkidl intrinsic.
    fn get_raw_context(&self, invoke: Invoke) -> Option<Ctx> {
        if self.invoke != invoke || self.context.is_null() {
            None
        } else {
            Some(self.context)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[derive(Clone)]
    pub struct Interface(Object);
    unsafe impl Sync for Interface {}
    unsafe impl Send for Interface {}
    impl Interface {
        fn validate(&self) {
            unsafe {
                self.0.invoke(3, std::ptr::NonNull::dangling().as_ptr(), 0);
            }
        }
    }
    trait IInterface {
        fn validate(&mut self);
    }
    struct Context {
        a: u8,
        b: u32,
        c: u32,
        d: u8,
    }
    impl IInterface for Context {
        fn validate(&mut self) {
            // Just here to test mutating doesn't result in data-races and that the optimizer
            // doesn't remove the writes all together.
            let tmp_a = self.a;
            unsafe {
                std::ptr::write_volatile(&mut self.a, 33);
            }
            assert_eq!(tmp_a, 10);
            unsafe {
                std::ptr::write_volatile(&mut self.a, std::hint::black_box(tmp_a));
            }

            assert_eq!(self.b, 11);
            assert_eq!(self.c, 12);
            assert_eq!(self.d, 13);
        }
    }
    static MARKER: Invoke = invoke;
    unsafe extern "C" fn invoke(h: Ctx, op: Op, _args: *mut Arg, _counts: Counts) -> i32 {
        unsafe {
            let cx = h.cast::<wrapper::Wrapper<dyn IInterface>>();
            match op {
                OP_RELEASE => {
                    wrapper::release(cx);
                }
                OP_RETAIN => {
                    wrapper::retain(cx);
                }
                _ => {
                    (*cx).inner.lock().unwrap().validate();
                }
            };
        }

        OK
    }

    #[test]
    fn ensure_object_layout() {
        assert_eq!(
            core::mem::size_of::<Object>(),
            core::mem::size_of::<Option<Object>>(),
            "Option<Object> and Object don't have similar layout"
        );
    }

    #[test]
    fn get_raw_context_valid_context() {
        static MARKER1: Invoke = invoke1;
        unsafe extern "C" fn invoke1(_h: Ctx, _op: Op, _args: *mut Arg, _counts: Counts) -> i32 {
            0
        }
        static MARKER2: Invoke = invoke2;
        unsafe extern "C" fn invoke2(_h: Ctx, _op: Op, _args: *mut Arg, _counts: Counts) -> i32 {
            1
        }

        let context = core::ptr::NonNull::dangling().as_ptr();
        let obj = unsafe { Object::create(MARKER1, context) };

        assert_eq!(obj.get_raw_context(MARKER1).unwrap(), context);
        assert!(obj.get_raw_context(MARKER2).is_none());
    }

    #[test]
    fn get_raw_context_invalid_context() {
        static MARKER1: Invoke = invoke1;
        unsafe extern "C" fn invoke1(_h: Ctx, _op: Op, _args: *mut Arg, _counts: Counts) -> i32 {
            0
        }

        let obj = unsafe { Object::create(MARKER1, core::ptr::null_mut()) };
        assert!(obj.get_raw_context(MARKER1).is_none());
    }

    #[test]
    fn transport_conversions() {
        use core::hint::black_box;

        #[repr(transparent)]
        struct NewType(Object);
        unsafe impl TypedObject for NewType {}

        let context = core::ptr::NonNull::dangling().as_ptr();
        unsafe extern "C" fn invoke(_h: Ctx, _op: Op, _args: *mut Arg, _counts: Counts) -> i32 {
            OK
        }

        let x = black_box(unsafe { NewType::from_raw(Object::create(invoke, context)) });
        let raw = black_box(x.into_raw());
        black_box(&raw);
        let x_ref = unsafe { black_box(NewType::from_raw_ref(&raw)) };
        black_box(x_ref);
    }

    #[test]
    fn downcast_modifying_state() {
        let mut counter = 0;
        let cx = Box::new(unsafe {
            wrapper::Wrapper::<dyn IInterface>::new::<Context>(Box::new(Context {
                a: 10,
                b: 11,
                c: 12,
                d: 13,
            }))
        });
        let interface = unsafe { Interface(Object::create(MARKER, Box::into_raw(cx).cast())) };
        for _ in 0..100 {
            wrapper::downcast_concrete::<_, _, dyn IInterface>(
                &interface.0,
                MARKER,
                |_: &Context| {
                    counter += 1;
                },
            )
            .unwrap();
        }
        assert_eq!(counter, 100);
    }

    mod thread_safety {
        use super::*;

        #[test]
        fn retain_release_sync() {
            let cx = Box::new(unsafe {
                wrapper::Wrapper::<dyn IInterface>::new::<Context>(Box::new(Context {
                    a: 10,
                    b: 11,
                    c: 12,
                    d: 13,
                }))
            });
            let interface = unsafe { Interface(Object::create(MARKER, Box::into_raw(cx).cast())) };
            std::thread::scope(|s| {
                let mut threads = vec![];
                (0..10).for_each(|_| threads.push(s.spawn(|| interface.clone())));
                threads.into_iter().for_each(|x| {
                    x.join().unwrap();
                });
            });
        }

        #[test]
        fn validate_sync() {
            let cx = Box::new(unsafe {
                wrapper::Wrapper::<dyn IInterface>::new::<Context>(Box::new(Context {
                    a: 10,
                    b: 11,
                    c: 12,
                    d: 13,
                }))
            });
            let interface = unsafe { Interface(Object::create(MARKER, Box::into_raw(cx).cast())) };
            std::thread::scope(|s| {
                let mut threads = vec![];
                (0..10).for_each(|_| threads.push(s.spawn(|| interface.validate())));
                threads.into_iter().for_each(|x| {
                    x.join().unwrap();
                });
            });
        }

        #[test]
        fn validate_send() {
            let cx = Box::new(unsafe {
                wrapper::Wrapper::<dyn IInterface>::new::<Context>(Box::new(Context {
                    a: 10,
                    b: 11,
                    c: 12,
                    d: 13,
                }))
            });
            let interface = unsafe { Interface(Object::create(MARKER, Box::into_raw(cx).cast())) };
            std::thread::scope(|s| {
                let mut threads = vec![];
                (0..10).for_each(|_| {
                    let c = interface.clone();
                    threads.push(s.spawn(move || c.validate()))
                });
                threads.into_iter().for_each(|x| {
                    x.join().unwrap();
                });
            });
        }
    }
}
